### **Part 2: The ADR - The Browser Regression Testing Doctrine**

You are correct that this entire strategic decision must be formalized in an ADR. Here is a professional-grade article, ready for you to save as `.github/ADR/002-browser-regression-testing.md`.

***

# **ADR-002: A Doctrine for Browser Regression Testing**

**Status:** Adopted | **Date:** 2025-08-03

## 1. Context & Dilemma

As `shuffrand` matures, our claim of being "browser-compatible" must evolve from an assumption into a guarantee. The `v1.7.0` "Proof of Quality" release mandates the creation of an automated test suite that validates the library's functionality in a real browser environment.

The core dilemma was not *if* we should test in the browser, but *how*. A simple test against local build artifacts (`/dist`) would only confirm that the code *can* run in a browser, but it would not protect us against critical, real-world failures. We needed a more rigorous approach.

## 2. The Core Tenets of Our Browser Testing Strategy

After careful consideration, we have adopted a hybrid testing strategy that is both **End-to-End (E2E)** and primarily serves as a **Regression Test** against our live, published package. This is a higher standard of quality assurance.

*   **It is an E2E Test:** The test validates the entire user workflow, from a "bare specifier" `import` (simulating a CDN) all the way through the execution of the final package code in a real browser.
*   **It is a Regression Test:** Its primary target is the **latest published, stable version** of `shuffrand` available on the `unpkg` CDN. Its core purpose is to answer the question: "Do our current local changes work with the code that is already in production?" This acts as a powerful post-publish smoke test and a continuous validation of our public API contract.

## 3. The Implementation Mandate

### A. The Tooling: Lean & Integrated
To avoid unnecessary complexity, we will **not** introduce a new, heavy E2E framework like Cypress. We will leverage the **Vitest browser mode**, powered by `@vitest/browser`. This aligns with our doctrine of using a lean, unified toolchain wherever possible.

### B. The Naming Convention
To maintain the integrity of our established `test.crypto-feature.###-description.ts` taxonomy, the new browser test files will be named as follows:
*   `test.crypto-random.006-realworld-regression.ts` (not finalized)
*   `test.crypto-shuffle.007-realworld-regression.ts` (not finalized)
*   `test.crypto-string.006-realworld-regressionn.ts` (not finalized)

These files will be dedicated solely to browser-based tests.

### C. The Configuration
The `vitest.config.ts` file will be updated with two key features:
1.  A `server.proxy` configuration that intelligently intercepts `import { ... } from 'shuffrand'` statements within the browser test and redirects them to the live `unpkg.com` CDN. This is the mechanism that enables our real-world regression testing.
2.  A `test.browser` block to configure the browser runner (we will use headless Edge), and `exclude` patterns to ensure that these slower, browser-specific tests are not run as part of our default, fast, Node.js-based `pnpm test` command.

### D. The Workflow
A new `pnpm` script, `test:browser`, will be created to execute this specific suite. This test will be a mandatory check in our `main.yml` CI workflow, guaranteeing that no code can be merged if it breaks compatibility with the last published version.

## 4. Final Decision

We are adopting a sophisticated, multi-layered testing strategy.
*   **`pnpm test`** remains our fast, local suite for validating **logical correctness** in a Node.js environment.
*   **`pnpm test:browser`** is our new, slightly slower suite for validating **real-world compatibility and preventing regressions** against our live, published package.

This approach provides the highest possible level of confidence and is a direct implementation of our "Quality is Architected, Not Added" principle.

***

### **Next Steps**

The doctrine is now clear. When you are ready, I will provide the final, canonical code for the `vitest.config.ts`, `package.json`, `tsconfig.test.json`, and the three new browser test files to implement this strategy.